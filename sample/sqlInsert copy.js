const { Markup } = require("telegraf");
const { restart, yes } = require("./button");
const { connection, checkConnection, streetCodes } = require("./accessDb");
const { authChatId } = require("./auth");
const { log, formatDate } = require("./plugin");

async function userInfoForInsert(userId, text, ctx, User) {
  try {
    if (!authChatId[userId]) {
      await User.updateOne({ user_id: userId }, { state: "null" });
      return ctx.replyWithHTML("–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–ª–∏—Å—å");
    }
    if (isNaN(text)) {
      return ctx.reply("–í–≤–µ–¥–∏—Ç–µ —Ü–∏—Ñ—Ä—ã!");
    }
    const user = await User.findOne({ user_id: userId });

    const locationCodeArray = authChatId[userId].section
      .map((value) => `'${value}'`)
      .join(",");

    await checkConnection();

    const query = `
SELECT 
CONSUM.CONSNAME AS consname,
CONSUM.FSBDVCODE,
CONSUM.STRTCODE AS streetCode,
CONSUM.HOUSE AS house, 
CONSUM.CONSCODE AS conscode, 
WCOUNT.FACTNUMB AS wmNumber, 
WCOUNT.WCODE AS wcode
FROM CONSUM
INNER JOIN WCOUNT 
ON CONSUM.CONSCODE = WCOUNT.CONSCODE
WHERE CONSUM.FSBDVCODE 
IN (${locationCodeArray}) 
AND WCOUNT.CONSCODE = ${text}`;

    const data = await connection.query(query);

    if (data.length > 0) {
      const buttons = [];
      const { consname, streetCode, house, conscode } = data[0];
      const streetName = streetCodes[streetCode];

      let profile = `
üë§ <b>[ ${conscode} ]</b>  <b><i>${consname}</i></b>
   <b><i>${streetName} ${house}</i></b>\n
–í—ã–±–µ—Ä–∏—Ç–µ —Å—á–µ—Ç—á–∏–∫ –≤–æ–¥—ã:`;
      for (const row of data) {
        const { wcode, wmNumber } = row;
        const buttonText =
          wmNumber !== null ? `${wmNumber.toString()}` : "–Ω–µ —É–∫–∞–∑–∞–Ω–æ";

        buttons.push([Markup.button.callback(buttonText, `wcode_${wcode}`)]);
      }
      await buttons.push([
        Markup.button.callback("–í–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–π –ª/c", "restart"),
      ]);
      const btn = Markup.inlineKeyboard(buttons);
      user.data = {
        ...user.data,
        consname,
        conscode,
        streetName,
        house,
      };
      await user.save();
      await User.updateOne({ user_id: userId }, { state: "insertWaterNumber" });
      await ctx.replyWithHTML(profile, btn);
    } else {
      ctx.reply("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ –Ω–æ–º–µ—Ä–∞.");
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
    ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã.");
  }
}

async function wcodeInfoForInsert(ctx, User) {
  try {
    const chatId = ctx.chat.id;
    const callbackData = ctx.match.input;
    const wcode = callbackData.replace("wcode_", "");
    const user = await User.findOne({ user_id: chatId });

    if (user.state === "insertWaterNumber") {
      await checkConnection();

      let data = await connection.query(
        `SELECT TOP 1 WCODE, Format([LASTDATE], 'mm.yyyy') AS FormattedDate, CURRCOUNT
         FROM WCHEAP
         WHERE WCODE = ${wcode}
         ORDER BY LASTDATE DESC`
      );

      const currentDate = new Date();
      const nowDate = formatDate(currentDate);

      if (!data[0]) {
        data = await connection.query(
          `SELECT WCODE, Format([DATESET], 'mm.yyyy') AS FormattedDate, STARTCOUNT AS CURRCOUNT
           FROM WCOUNT
           WHERE WCODE = ${wcode}`
        );
      }

      if (data[0]) {
        const { FormattedDate, CURRCOUNT, WCODE } = data[0];

        if (nowDate === FormattedDate) {
          await ctx.reply(
            "–î–∞–Ω–Ω—ã–µ –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü —É–∂–µ –≤–Ω–µ—Å–µ–Ω—ã!\n–í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π —Å—á–µ—Ç—á–∏–∫.\n–ò–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π",
            restart
          );
          await ctx.deleteMessage();
        } else {
          await ctx.answerCbQuery();
          await ctx.replyWithHTML(
            `<b>–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—É—â–µ–µ –ø–æ–∫–∞–∑–∞–Ω–∏–µ</b>\n   –ø–æ—Å–ª–µ–¥–Ω–µ–µ - <b>${CURRCOUNT}</b>`
          );

          user.data = {
            ...user.data,
            WCODE,
            CURRCOUNT,
            FormattedDate,
          };

          await user.save();
          await User.updateOne({ user_id: chatId }, { state: "insertValue" });
        }
      } else {
        await ctx.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞.");
      }
    } else {
      await ctx.reply("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.");
    }
  } catch (e) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞:", e);
    await ctx.reply(
      "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
    );
  }
}

async function insertValue(chatId, text, ctx, User) {
  try {
    const user = await User.findOne({ user_id: chatId });

    if (!user) {
      return ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    }

    if (isNaN(text) || parseInt(text) < 0) {
      return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ!");
    }

    const LASTCOUNT = parseInt(text);

    const { CURRCOUNT, WCODE } = user.data;
    const diff = LASTCOUNT - CURRCOUNT;
    user.data = {
      ...user.data,
      LASTCOUNT,
    };
    await user.save();

    if (diff > 50) {
      return ctx.replyWithHTML(
        `–†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –≤–≤–µ–¥–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º\n<b>[ ${diff} ]</b> —ç—Ç–æ –±–æ–ª—å—à–µ —á–µ–º 50.\n–ù–∞–∂–º–∏—Ç–µ "–î–∞", –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ`,
        yes
      );
    } else if (diff <= 50 && LASTCOUNT > CURRCOUNT) {
      try {
        const currentDate = new Date().toISOString().slice(0, 10); // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD

        const sqlQuery = `
        INSERT
        INTO WCHEAP
        VALUES ('${WCODE}', '${currentDate}', ${LASTCOUNT}, ${CURRCOUNT}, null)`;

        // const sqlQuery = `
        // INSERT INTO WCHEAP
        // VALUES (${WCODE}, #09/30/2024#, ${LASTCOUNT}, ${CURRCOUNT}, null)`;

        await connection.execute(sqlQuery);

        await ctx.reply("–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –≤—Å—Ç–∞–≤–ª–µ–Ω—ã.\n–í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–π –ª/—Å!");
        await User.updateOne({ user_id: chatId }, { state: "insertConscode" });
        await log(user, authChatId, chatId, ctx);
      } catch (dbError) {
        console.log("–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:", dbError);
        return ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.");
      }
    } else {
      return ctx.replyWithHTML(
        `–í–Ω–µ—Å–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –º–µ–Ω—å—à–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–∫–∞–∑–∞–Ω–∏—è <b>[${CURRCOUNT}]</b>\n–í–Ω–µ—Å–∏—Ç–µ –¥—Ä—É–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ –≤–æ–∑–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥—Ä—É–≥–æ–≥–æ –ª/c!`,
        restart
      );
    }
  } catch (error) {
    console.log("–û–±—â–∞—è –æ—à–∏–±–∫–∞:", error);
    return ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ.");
  }
}

async function insertIfYes(ctx, User) {
  try {
    const chatId = ctx.from.id;
    const user = await User.findOne({ user_id: chatId });

    if (!user) {
      return ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    }

    const { CURRCOUNT, WCODE, LASTCOUNT } = user.data;
    const DATE = new Date().toISOString().slice(0, 10);

    await checkConnection();

    const query = `
    INSERT INTO WCHEAP
    VALUES ('${WCODE}', '${DATE}', ${LASTCOUNT}, ${CURRCOUNT}, null)`;

    // const query = `
    // INSERT INTO WCHEAP
    // VALUES (${WCODE}, #09/30/2024#,  ${LASTCOUNT}, ${CURRCOUNT}, null)`;

    await connection.execute(query);

    await ctx.reply("–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –≤—Å—Ç–∞–≤–ª–µ–Ω—ã.\n–í–≤–µ–¥–∏—Ç–µ –ª/—Å!");

    await User.updateOne({ user_id: chatId }, { state: "insertConscode" });
    await log(user, authChatId, chatId, ctx);
  } catch (error) {
    console.log("–û—à–∏–±–∫–∞ insertIfYes", error);
    await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
  }
}

module.exports = {
  userInfoForInsert,
  wcodeInfoForInsert,
  insertValue,
  insertIfYes,
};
