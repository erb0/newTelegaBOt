const {
  connection,
  checkConnection,
  deskCodes,
  paymentCodes,
  streetCodes,
} = require("./accessDb");
const { menu, cheap, payments, byWm } = require("./button");
const { logInfo } = require("./plugin");
const { authChatId } = require("./auth");
const { logInfoMongo } = require("./mongoDb");

function validateNumberInput(input, ctx) {
  if (isNaN(input)) {
    ctx.reply("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");
    return false;
  }
  return true;
}

function buildUserProfile(data, searchValue) {
  const { consname, streetCode, house, debt, dateRep, w, ww } = data;
  const streetName = streetCodes[streetCode] || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —É–ª–∏—Ü–∞";
  const wCheckBox = w > 0 ? "‚úÖ" : "‚ùå";
  const wwCheckBox = ww > 0 ? "‚úÖ" : "‚ùå";
  return `üë§ ( ${searchValue} ) ${consname}
üè† –∞–¥—Ä–µ—Å: ${streetName} ${house}
üí∞ –¥–æ–ª–≥: ${debt.toFixed(2)} —Ç–≥
üßæ –¥–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞: ${dateRep.slice(0, 10)}
üö∞ —Ç–∞—Ä–∏—Ñ
${wCheckBox} –≤–æ–¥–∞: ${w.toFixed(2)} —Ç–≥
${wwCheckBox} –∫–∞–Ω–∞–ª–∏–∑–∞—Ü–∏—è: ${ww.toFixed(2)} —Ç–≥`;
}

async function searchByUser(locationCodeArray, searchValue, ctx, User) {
  try {
    if (!validateNumberInput(searchValue, ctx)) return;

    const chatId = ctx.from.id;
    const name = authChatId[chatId]?.name || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π";
    logInfo(chatId, name, searchValue, "–õ—Å—á–µ—Ç", ctx);
    logInfoMongo(chatId, name, searchValue, "–õ—Å—á–µ—Ç", ctx);
    await checkConnection();

    const query = `SELECT CONSUM.CONSNAME AS consname, CONSUM.STRTCODE AS streetCode, CONSUM.HOUSE AS house,
                   –∑TOTPAY_ALL_–¢–µ–∫.–î–æ–ª–≥ AS debt, –∑TOTPAY_ALL_–¢–µ–∫.–î–∞—Ç–∞–†—Å—á AS dateRep,
                   –∑TOTPAY_ALL_–¢–µ–∫.–¢—Ä—Ñ–ü–∏—Ç AS w, –∑TOTPAY_ALL_–¢–µ–∫.–¢—Ä—Ñ–ö–∞–Ω AS ww
                   FROM CONSUM INNER JOIN –∑TOTPAY_ALL_–¢–µ–∫ 
                   ON CONSUM.CONSCODE = –∑TOTPAY_ALL_–¢–µ–∫.CONSCODE
                   WHERE CONSUM.FSBDVCODE IN (${locationCodeArray}) 
                   AND CONSUM.CONSCODE = ${searchValue};`;

    const data = await connection.query(query);

    if (data.length > 0) {
      const userProfile = buildUserProfile(data[0], searchValue);
      const user = await User.findOne({ user_id: chatId });

      if (user?.data?.sentMessage) {
        try {
          await ctx.telegram.deleteMessage(chatId, user.data.sentMessage);
        } catch (deleteError) {
          if (deleteError.response?.error_code !== 400) {
            console.error(
              "–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:",
              deleteError
            );
          }
        }
      }

      const sentMessage = await ctx.replyWithHTML(userProfile, menu);
      user.data = {
        ...user.data,
        searchValue,
        consname: data[0].consname,
        sentMessage: sentMessage.message_id,
        userProfile,
      };
      await user.save();
    } else {
      await ctx.reply(`–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –ª/—Å ${searchValue}`);
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
    await ctx.reply(
      "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
    );
  }
}

async function searchWmOrName(text, ctx, searchField) {
  try {
    await checkConnection();
    const chatId = ctx.from.id;
    const name = authChatId[chatId]?.name || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π";
    logInfo(chatId, name, text, searchField === "wm" ? "–≤/–º" : "—Ñ–∏–æ", ctx);

    const query = `SELECT * FROM –∑_–ê–±–æ–Ω–µ–Ω—Ç—ã–í–ú WHERE [${searchField}] LIKE '%${text}%'`;
    const data = await connection.query(query);

    if (data.length > 0) {
      for (const { userId, user, location, wm } of data) {
        const userProfile = `–õ/—Å: ${userId}
–ê–±–æ–Ω–µ–Ω—Ç: ${user}
–£—á–∞—Å—Ç–æ–∫: ${location}
–í–æ–¥–æ–º–µ—Ä: ${wm}`;
        await ctx.replyWithHTML(userProfile, byWm(userId));
        await new Promise((res) => setTimeout(res, 500));
      }
    } else {
      ctx.reply(
        `–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è ${searchField === "wm" ? "–≤/–º" : "—Ñ–∏–æ"} ${text}`
      );
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
  }
}

const searchByWm = (text, ctx) =>
  validateNumberInput(text, ctx) && searchWmOrName(text, ctx, "wm");
const searchByName = (text, ctx) => searchWmOrName(text, ctx, "name");

async function searchPayment(User, ctx) {
  try {
    const chatId = ctx.from.id;
    const user = await User.findOne({ user_id: chatId });

    let message = `üë§ ( ${user.data.searchValue} ) ${user.data.consname}
–°–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ–ø–ª–∞—Ç:
üìÖ –î–∞—Ç–∞ üí≥ –ö–∞—Å—Å–∞ üìë –í–∏–¥.–æ–ø–ª üí∞ –°—É–º–º–∞\n`;
    const sqlQuery = `SELECT TOP 12 SUMMA AS summa, PDESKCODE AS deskCode, PDATE AS pdate, GROUPCODE AS paymentCode FROM HEAP WHERE CONSCODE = ${user.data.searchValue} ORDER BY PDATE DESC`;

    await checkConnection();
    const data = await connection.query(sqlQuery);

    if (data.length > 0) {
      message += data
        .map(({ summa, deskCode, pdate, paymentCode }) => {
          return `${pdate.substring(0, 10)}, ${deskCodes[deskCode] || ""}, ${
            paymentCodes[paymentCode] || ""
          }, ${summa.toFixed(2)} —Ç–≥`;
        })
        .join("\n");

      const sentMessage = await ctx.telegram.editMessageText(
        chatId,
        user.data.sentMessage,
        null,
        message,
        cheap
      );
      user.data.sentMessage = sentMessage.message_id;
      await user.save();
    } else {
      ctx.reply(`–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –ª/—Å ${user.data.searchValue}`);
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
  }
}

async function searchCheap(User, ctx) {
  try {
    const chatId = ctx.from.id;
    const user = await User.findOne({ user_id: chatId });
    const searchQuery = `SELECT DISTINCT WCODE, FACTNUMB, DATESET FROM WCOUNT WHERE CONSCODE = ${user.data.searchValue}`;
    const waterMeters = await connection.query(searchQuery);

    let formattedResult = `üë§ ( ${user.data.searchValue} ) ${user.data.consname}\n`;

    for (const { WCODE, FACTNUMB, DATESET } of waterMeters) {
      formattedResult += `–ù–æ–º–µ—Ä –≤–æ–¥–æ–º–µ—Ä–∞: ${FACTNUMB}\n–î–∞—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${DATESET.slice(
        0,
        10
      )}\nüìÖ –î–∞—Ç–∞ | üìã–ü–æ–∫–∞–∑–∞–Ω–∏—è\n`;

      const result = await connection.query(
        `SELECT TOP 12 CURRCOUNT, LASTDATE FROM WCHEAP WHERE WCODE = ${WCODE} ORDER BY LASTDATE DESC`
      );

      result.forEach(({ CURRCOUNT, LASTDATE }) => {
        formattedResult += `${LASTDATE.slice(0, 10)} | ${CURRCOUNT}\n`;
      });

      formattedResult += "------------------------\n";
    }

    const sentMessage = await ctx.telegram.editMessageText(
      chatId,
      user.data.sentMessage,
      null,
      formattedResult,
      payments
    );
    user.data.sentMessage = sentMessage.message_id;
    await user.save();
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
  }
}

async function back(User, ctx) {
  try {
    const chatId = ctx.from.id;
    const user = await User.findOne({ user_id: chatId });
    const sentMessage = await ctx.telegram.editMessageText(
      chatId,
      user.data.sentMessage,
      null,
      user.data.userProfile,
      menu
    );
    user.data.sentMessage = sentMessage.message_id;
    await user.save();
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:", error);
  }
}

module.exports = {
  searchByName,
  searchPayment,
  searchCheap,
  searchByUser,
  searchByWm,
  back,
};
